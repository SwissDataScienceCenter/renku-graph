/*
 * Copyright 2022 Swiss Data Science Center (SDSC)
 * A partnership between École Polytechnique Fédérale de Lausanne (EPFL) and
 * Eidgenössische Technische Hochschule Zürich (ETHZ).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.renku.graph.acceptancetests

import io.renku.eventlog.TypeSerializers
import io.renku.events.CategoryName
import io.renku.generators.CommonGraphGenerators.authUsers
import io.renku.generators.Generators.Implicits._
import io.renku.graph.acceptancetests.data.Project.Statistics.CommitsCount
import io.renku.graph.acceptancetests.data.dataProjects
import io.renku.graph.acceptancetests.db.EventLog
import io.renku.graph.acceptancetests.flows.TSProvisioning
import io.renku.graph.acceptancetests.tooling.GraphServices
import io.renku.graph.model.EventsGenerators.commitIds
import io.renku.graph.model.events.EventId
import io.renku.graph.model.events.EventStatus.TriplesStore
import io.renku.graph.model.testentities.generators.EntitiesGenerators._
import io.renku.webhookservice.model.HookToken
import org.http4s.Status._
import org.scalatest.GivenWhenThen
import org.scalatest.featurespec.AnyFeatureSpec

class CommitSyncFlowsSpec
    extends AnyFeatureSpec
    with GivenWhenThen
    with GraphServices
    with TSProvisioning
    with TypeSerializers {

  Feature("Missed GitLab events should be synchronised") {

    Scenario("There's a commit in GitLab for which there's no event in EL") {

      val user              = authUsers.generateOne
      val project           = dataProjects(renkuProjectEntities(visibilityPublic), CommitsCount(2)).generateOne
      val nonMissedCommitId = commitIds.generateOne
      val missedCommitId    = commitIds.generateOne

      Given("commit with the commit id matching Push Event's 'after' exists on the project in GitLab")
      And("fetch latest commit endpoint returns the non missed commit")
      And("project exists in GitLab")
      gitLabStub.addAuthenticated(user)
      gitLabStub.setupProject(project, nonMissedCommitId)

      And("Triples are generated by the Remote Triples Generator for both commits")
      `GET <triples-generator>/projects/:id/commits/:id returning OK with some triples`(project, nonMissedCommitId)
      `GET <triples-generator>/projects/:id/commits/:id returning OK with some triples`(project, missedCommitId)

      And("access token is present")
      givenAccessTokenPresentFor(project, user.accessToken)

      When("a Push Event arrives for the non missed event")
      webhookServiceClient
        .POST("webhooks/events", HookToken(project.id), data.GitLab.pushEvent(project, nonMissedCommitId))
        .status shouldBe Accepted

      And("relevant commit events are processed")
      `wait for events to be processed`(project.id)

      Then("the non missed events should be in the Triples Store")
      eventually {
        EventLog.findEvents(project.id) should contain(EventId(nonMissedCommitId.value) -> TriplesStore)
      }

      And("fetch latest commit endpoint returns the missed and the non missed commit")
      gitLabStub.replaceCommits(project.id, missedCommitId, nonMissedCommitId)

      When("commit synchronisation process kicks-off")
      EventLog.forceCategoryEventTriggering(CategoryName("COMMIT_SYNC"), project.id)

      And("commit events for the missed event are created and processed")
      `wait for events to be processed`(project.id)

      Then("triples for both of the project's commits should be in the Triples Store")
      eventually {
        EventLog.findEvents(project.id) should contain theSameElementsAs List(
          EventId(nonMissedCommitId.value) -> TriplesStore,
          EventId(missedCommitId.value)    -> TriplesStore
        )
      }
    }
  }
}
