/*
 * Copyright 2024 Swiss Data Science Center (SDSC)
 * A partnership between École Polytechnique Fédérale de Lausanne (EPFL) and
 * Eidgenössische Technische Hochschule Zürich (ETHZ).
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.renku.graph.acceptancetests

import cats.data.NonEmptyList
import data.Project.Statistics.CommitsCount
import data._
import db.EventLog
import flows.TSProvisioning
import io.renku.eventlog.TypeSerializers
import io.renku.events.CategoryName
import io.renku.generators.CommonGraphGenerators.authUsers
import io.renku.generators.Generators.Implicits._
import io.renku.graph.model.EventsGenerators.commitIds
import io.renku.graph.model.events.EventId
import io.renku.graph.model.events.EventStatus.TriplesStore
import io.renku.graph.model.projects.Role
import io.renku.graph.model.testentities.cliShapedPersons
import io.renku.graph.model.testentities.generators.EntitiesGenerators._
import tooling.{AcceptanceSpec, ApplicationServices}

class CommitSyncFlowsSpec extends AcceptanceSpec with ApplicationServices with TSProvisioning with TypeSerializers {

  Feature("Missed GitLab events should be synchronised") {

    Scenario("There's a commit in GitLab for which there's no event in EL") {

      val user = authUsers.generateOne
      val project =
        dataProjects(renkuProjectEntities(visibilityPublic, creatorGen = cliShapedPersons).modify(removeMembers()),
                     CommitsCount(2)
        ).map(addMemberWithId(user.id, Role.Owner)).generateOne

      Given("commit with the commit id matching Push Event's 'after' exists on the project in GitLab")
      And("fetch latest commit endpoint returns the non missed commit")
      And("project exists in GitLab")
      gitLabStub.addAuthenticated(user)

      val nonMissedCommitId = commitIds.generateOne
      gitLabStub.setupProject(project, nonMissedCommitId)

      And("Triples are generated by the Remote Triples Generator for both commits")
      val missedCommitId = commitIds.generateOne
      `GET <triples-generator>/projects/:id/commits/:id returning OK with some triples`(project, nonMissedCommitId)
      `GET <triples-generator>/projects/:id/commits/:id returning OK with some triples`(project, missedCommitId)

      And("relevant commit events are processed")
      `data in the Triples Store`(project, nonMissedCommitId, user.accessToken)

      Then("the non missed events should be in the Triples Store")
      eventually {
        EventLog.findEvents(project.id) should contain(EventId(nonMissedCommitId.value) -> TriplesStore)
      }

      And("fetch latest commit endpoint returns the missed and the non missed commit")
      gitLabStub.replaceCommits(project.id, missedCommitId, nonMissedCommitId)

      When("commit synchronisation process kicks-off")
      EventLog.forceCategoryEventTriggering(CategoryName("COMMIT_SYNC"), project.id)

      And("commit events for the missed event are created and processed")
      `data in the Triples Store`(project, NonEmptyList.of(missedCommitId, nonMissedCommitId), user.accessToken)

      Then("triples for both of the project's commits should be in the Triples Store")
      eventually {
        EventLog.findEvents(project.id) should contain theSameElementsAs List(
          EventId(nonMissedCommitId.value) -> TriplesStore,
          EventId(missedCommitId.value)    -> TriplesStore
        )
      }
    }
  }
}
